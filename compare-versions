#!/usr/bin/env python3

import argparse
import os
import fnmatch
import subprocess
import tempfile
import shutil
import git
import se


def main():
	parser = argparse.ArgumentParser(description="Use Firefox to render and compare XHTML files in an ebook repository. Run on a dirty repository to visually compare the repository's dirty state with its clean state.")
	parser.add_argument("-i", "--include-common", dest="include_common_files", action="store_true", help="include commonly-excluded files like imprint, titlepage, and colophon")
	parser.add_argument("targets", metavar="TARGET", nargs="+", help="a directory containing XHTML files")
	args = parser.parse_args()

	firefox_path = shutil.which("firefox")
	compare_path = shutil.which("compare")

	# Check for some required tools.
	if firefox_path is None:
		se.print_error("Couldn't locate firefox. Is it installed?")
		exit(1)

	if compare_path is None:
		se.print_error("Couldn't locate compare. Is imagemagick installed?")
		exit(1)

	# Firefox won't start in headless mode if there is another Firefox process running; check that here.
	is_firefox_running = True
	try:
		subprocess.check_output(["pidof", "firefox"])
	except Exception:
		is_firefox_running = False

	if is_firefox_running:
		se.print_error("Firefox is currently running. It must be closed in order to run headless.")
		exit(1)

	for target in args.targets:
		target = os.path.abspath(target)

		print("Processing {} ...\n".format(target), end="", flush=True)

		target_filenames = set()
		if os.path.isdir(target):
			for root, _, filenames in os.walk(target):
				for filename in fnmatch.filter(filenames, "*.xhtml"):
					if args.include_common_files or filename not in se.IGNORED_FILENAMES:
						target_filenames.add(os.path.join(root, filename))
		else:
			se.print_error("Target must be a directory.")
			exit(1)


		git_command = git.cmd.Git(target)

		if "nothing to commit" in git_command.status():
			se.print_error("Repo is clean. This script must be run on a dirty repo.", True)
			continue

		# Put Git's changes into the stash
		git_command.stash()

		with tempfile.TemporaryDirectory() as temp_directory_path:
			# Generate screenshots of the pre-change repo
			for filename in target_filenames:
				subprocess.run([firefox_path, "-screenshot", "{}/{}.orig.png".format(temp_directory_path, os.path.basename(filename)), filename], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

			# Pop the stash
			git_command.stash("pop")

			# Generate screenshots of the post-change repo, and compare them to the old screenshots
			for filename in target_filenames:
				subprocess.run([firefox_path, "-screenshot", "{}/{}.new.png".format(temp_directory_path, os.path.basename(filename)), filename], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

				output = subprocess.run([compare_path, "-metric", "ae", "{}/{}.orig.png".format(temp_directory_path, os.path.basename(filename)), "{}/{}.new.png".format(temp_directory_path, os.path.basename(filename)), "{}/temp.png".format(temp_directory_path)], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT).stdout.decode().strip()

				if output != "0":
					print("\tDifference in {}\n".format(filename), end="", flush=True)


if __name__ == "__main__":
	main()
